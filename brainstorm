Start small -- implement the smallest subset of lisp/arc one can get away with

datatypes: symbols, strings, numbers, functions
if
t, nil
fn

quote
quasiquote
    unquote
    unquote-splicing

for datatypes, maybe define them as such:

    class DataType:
        toString: how an instance is displayer
        value: the actual value stored in the type?
        type: the name of the datatype?

    or maybe not; I'm thinking of this only as a way to unify symbols (which don't exist in JS) with other types like strings and numbers (which DO existin JS)

    functions do exist in JS, but I don't know .. they're not "exactly" the same ..

    besdies quasiquoting, a big challenge will be implementing colsures ..

----------------------------

in coffeescript, we implement a basic lisp

then we implement an Arc on top of it (as macros)

For instance, we implement lambda as:
    (lambda arguments statement statement ....)

And then implement the arc 'fn' as a macro on top of it

we implement a basic 'set' form, and implement the Arc '=' on top of it.

It's probably a good idea to use underscores in these "basic" forms' names so people don't use them, e.g. __lambda__

lambda is also what "do" would build on: it evaluates its "body" expressions in order and returns the last one

lambda also creates its own scope,

and the "var" form creates local variables (I think this should be a good idea)

instead of the "Arc" way of building a "let" macro on top of "fn"

I'm not sure how much is required to build destructuring, though, let's hope that much is enough ..

------

see http://files.arcfn.com/foundation-doc.html for a list of builtins we need to support!

of course, we're not cloning everything; no need to rely on dr.raket APIs when we have node/js APIs

----

next we have: quoting, local variable creation

for quoting, we need the reader to transform 'x and '(a b c), etc to (quote x) and (quote (a b c))

for other things like a!b, we read the whole thing as a symbol, but at some point before evaluation, we transorm it to its proper form .. I still don't know how; must look at arc's ssexpand or something like that

-----

perhaps before local variable .. the builtin eval is very important! It would probably allow us to make a REPL and experiment with "macros" in it

----

maybe there's no need to "declare" local variables; if you set a variable that doesn't exist, it will just be local (like coffee script)

what happens (and what should happen) if a variable exists on the outer scope and you use its name? create a local one? just use the outer one?

-------

special syntax, e.g. a!b
like arc, keep it as one symbol

when eval'ing a symbol with special syntax, it gets expanded and then re-eval'ed

-----------

I think, at this point, only thing remaining in our way before having useful macros is destructuring assignment

